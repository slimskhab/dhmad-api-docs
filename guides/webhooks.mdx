---
title: Webhooks
description: Set up real-time notifications for escrow and contract events
---

Webhooks allow you to receive real-time notifications when events occur in your escrow transactions. This guide explains how to set up and use webhooks.

## Overview

Webhooks are HTTP callbacks that notify your application when escrow or contract events occur. Instead of polling the API, you can receive instant notifications when:

- Escrow status changes (pending → paid → delivered → completed → cancelled)
- Escrows are cancelled
- A contract is signed by the seller or buyer
- Any status update occurs

## Setting Up Webhooks

### Step 1: Create Webhook Endpoint

Create an HTTP endpoint in your application that can receive POST requests:

<CodeGroup>
```javascript Express.js
const express = require('express');
const crypto = require('crypto');
const app = express();

app.use(express.json());

app.post('/webhooks/dhmad', async (req, res) => {
const signature = req.headers['x-webhook-signature'];
const event = req.headers['x-webhook-event'];
const payload = JSON.stringify(req.body);

// Verify webhook signature (see verification section)
// Process the event
// Return 200 OK quickly

res.status(200).send('OK');
});

app.listen(3000);

````

```python Flask
from flask import Flask, request, jsonify
import hmac
import hashlib

app = Flask(__name__)

@app.route('/webhooks/dhmad', methods=['POST'])
def webhook():
    signature = request.headers.get('X-Webhook-Signature')
    event = request.headers.get('X-Webhook-Event')
    payload = request.get_json()

    # Verify webhook signature (see verification section)
    # Process the event
    # Return 200 OK quickly

    return jsonify({'status': 'ok'}), 200

if __name__ == '__main__':
    app.run(port=3000)
````

```php Laravel
<?php

namespace App\Http\Controllers;

use Illuminate\Http\Request;

class WebhookController extends Controller
{
    public function handle(Request $request)
    {
        $signature = $request->header('X-Webhook-Signature');
        $event = $request->header('X-Webhook-Event');
        $payload = $request->all();

        // Verify webhook signature (see verification section)
        // Process the event
        // Return 200 OK quickly

        return response()->json(['status' => 'ok'], 200);
    }
}
```

</CodeGroup>

### Step 2: Configure Webhook in Dashboard

1. Log into the [Developer Dashboard](https://developer.dhmad.tn/dashboard)
2. Navigate to the "Webhooks" section
3. Click "Create Webhook"
4. Enter your webhook URL (must be HTTPS in production)
5. The webhook will automatically subscribe to `escrow.status.updated` events

<Warning>
  You can create a maximum of 2 webhooks per developer account. Choose your
  endpoints carefully.
</Warning>

<Info>
  In development mode, HTTP URLs are allowed. In production, only HTTPS URLs are
  accepted.
</Info>

## Webhook Events

You can subscribe to the following events:

<CardGroup cols={1}>
  <Card title="escrow.status.updated" icon="refresh">
    Triggered when an escrow status changes (pending → paid → delivered →
    completed → cancelled)
  </Card>
  <Card title="contract.signed" icon="file-signature">
    Triggered when the escrow contract is signed by the seller or the buyer.
    Each signature triggers one event; `data.contract.signedBy` indicates who
    signed ("seller" or "buyer").
  </Card>
</CardGroup>

## Event Payload

All webhook events share the same top-level structure: `id`, `type`, `timestamp`, and `data`. The `data` object depends on the event type.

### escrow.status.updated

```json
{
  "id": "550e8400-e29b-41d4-a716-446655440000",
  "type": "escrow.status.updated",
  "timestamp": "2024-01-15T10:30:00Z",
  "data": {
    "escrow": {
      "id": "507f1f77bcf86cd799439011",
      "title": "Web Development Service",
      "amount": 1000.0,
      "escrowFee": 50.0,
      "status": "paid",
      "oldStatus": "pending",
      "seller": {
        "_id": "507f1f77bcf86cd799439013",
        "email": "seller@example.com",
        "firstName": "John",
        "lastName": "Doe"
      },
      "buyer": {
        "_id": "507f1f77bcf86cd799439014",
        "email": "buyer@example.com",
        "firstName": "Jane",
        "lastName": "Smith"
      },
      "estimatedDeliveryDays": 7,
      "createdAt": "2024-01-15T10:00:00Z",
      "updatedAt": "2024-01-15T10:30:00Z"
    }
  }
}
```

### contract.signed

Sent when the seller or the buyer signs the contract (one event per signature).

```json
{
  "id": "550e8400-e29b-41d4-a716-446655440001",
  "type": "contract.signed",
  "timestamp": "2024-01-15T11:00:00Z",
  "data": {
    "contract": {
      "id": "507f1f77bcf86cd799439012",
      "escrowId": "507f1f77bcf86cd799439011",
      "signedBy": "seller",
      "sellerSignature": { "signedAt": "2024-01-15T11:00:00Z" },
      "buyerSignature": null,
      "isFullySigned": false,
      "signedAt": "2024-01-15T11:00:00Z"
    },
    "escrow": {
      "id": "507f1f77bcf86cd799439011",
      "title": "Web Development Service",
      "amount": 1000.0,
      "escrowFee": 50.0,
      "status": "pending",
      "seller": {
        "_id": "507f1f77bcf86cd799439013",
        "email": "seller@example.com",
        "firstName": "John",
        "lastName": "Doe"
      },
      "buyer": {
        "_id": "507f1f77bcf86cd799439014",
        "email": "buyer@example.com",
        "firstName": "Jane",
        "lastName": "Smith"
      },
      "estimatedDeliveryDays": 7,
      "createdAt": "2024-01-15T10:00:00Z",
      "updatedAt": "2024-01-15T11:00:00Z"
    }
  }
}
```

### Payload Fields

<ParamField response="id" type="string">
  Unique identifier for this webhook event
</ParamField>

<ParamField response="type" type="string">
  Event type: "escrow.status.updated" or "contract.signed"
</ParamField>

<ParamField response="timestamp" type="string">
  ISO 8601 timestamp when the event occurred
</ParamField>

<ParamField response="data.escrow.id" type="string">
  Escrow ID
</ParamField>

<ParamField response="data.escrow.status" type="string">
  Escrow status (pending, paid, delivered, completed, cancelled). For
  contract.signed, oldStatus is not present.
</ParamField>

<ParamField response="data.escrow.oldStatus" type="string">
  Previous escrow status (escrow.status.updated only)
</ParamField>

<ParamField response="data.contract" type="object">
  Present for contract.signed only. Contains contract id, escrowId, signedBy
  ("seller" or "buyer"), signature timestamps, and isFullySigned.
</ParamField>

<ParamField response="data.contract.signedBy" type="string">
  Who signed in this event: "seller" or "buyer"
</ParamField>

## Webhook Headers

Each webhook request includes the following headers:

<ParamField response="X-Webhook-Signature" type="string">
  HMAC SHA256 signature of the payload. Use this to verify the webhook is from
  DHMAD.
</ParamField>

<ParamField response="X-Webhook-Event" type="string">
  The event type (e.g., "escrow.status.updated", "contract.signed")
</ParamField>

<ParamField response="Content-Type" type="string">
  Always "application/json"
</ParamField>

## Verifying Webhook Signatures

Always verify webhook signatures to ensure requests are from DHMAD and haven't been tampered with.

### Getting Your Webhook Secret

The webhook secret is generated automatically when you create a webhook. You can retrieve it from the webhook details in your dashboard (it's only shown once when created).

<Warning>
  Store your webhook secret securely. Never commit it to version control or
  expose it publicly.
</Warning>

### Signature Verification Examples

<CodeGroup>
```javascript Node.js
const crypto = require('crypto');

function verifyWebhookSignature(payload, signature, secret) {
const expectedSignature = crypto
.createHmac('sha256', secret)
.update(JSON.stringify(payload))
.digest('hex');

return crypto.timingSafeEqual(
Buffer.from(signature),
Buffer.from(expectedSignature)
);
}

// In your webhook handler
app.post('/webhooks/dhmad', express.json(), (req, res) => {
const signature = req.headers['x-webhook-signature'];
const secret = process.env.DHMAD_WEBHOOK_SECRET;

if (!verifyWebhookSignature(req.body, signature, secret)) {
return res.status(401).send('Invalid signature');
}

// Process webhook
console.log('Webhook verified:', req.body);
res.status(200).send('OK');
});

````

```python Python
import hmac
import hashlib
import json

def verify_webhook_signature(payload, signature, secret):
    expected_signature = hmac.new(
        secret.encode('utf-8'),
        json.dumps(payload, separators=(',', ':')).encode('utf-8'),
        hashlib.sha256
    ).hexdigest()

    return hmac.compare_digest(signature, expected_signature)

# In your webhook handler
@app.route('/webhooks/dhmad', methods=['POST'])
def webhook():
    signature = request.headers.get('X-Webhook-Signature')
    secret = os.getenv('DHMAD_WEBHOOK_SECRET')
    payload = request.get_json()

    if not verify_webhook_signature(payload, signature, secret):
        return jsonify({'error': 'Invalid signature'}), 401

    # Process webhook
    print('Webhook verified:', payload)
    return jsonify({'status': 'ok'}), 200
````

```php PHP
<?php

function verifyWebhookSignature($payload, $signature, $secret) {
    $expectedSignature = hash_hmac('sha256', json_encode($payload), $secret);
    return hash_equals($expectedSignature, $signature);
}

// In your webhook handler
public function handle(Request $request) {
    $signature = $request->header('X-Webhook-Signature');
    $secret = env('DHMAD_WEBHOOK_SECRET');
    $payload = $request->all();

    if (!verifyWebhookSignature($payload, $signature, $secret)) {
        return response()->json(['error' => 'Invalid signature'], 401);
    }

    // Process webhook
    Log::info('Webhook verified:', $payload);
    return response()->json(['status' => 'ok'], 200);
}
```

</CodeGroup>

## Best Practices

<CardGroup cols={2}>
  <Card title="Verify Signatures" icon="shield-check">
    Always verify webhook signatures before processing. This ensures the request
    is from DHMAD and hasn't been tampered with.
  </Card>
  <Card title="Respond Quickly" icon="bolt">
    Return 200 OK within 5 seconds. Process the webhook asynchronously if
    needed.
  </Card>
  <Card title="Idempotency" icon="refresh">
    Handle duplicate events gracefully. Use the event `id` to track processed
    events.
  </Card>
  <Card title="Error Handling" icon="exclamation-triangle">
    Log errors and implement retry logic for failed processing. Don't fail the
    webhook response.
  </Card>
  <Card title="HTTPS Only" icon="lock">
    Use HTTPS endpoints in production. HTTP is only allowed in development.
  </Card>
  <Card title="Monitor Failures" icon="chart-line">
    Track webhook delivery failures in your dashboard and set up alerts.
  </Card>
</CardGroup>

## Webhook Delivery

### Retry Logic

If your endpoint doesn't return a 200 OK status within 10 seconds, DHMAD will retry the webhook:

- **Retries**: Up to 3 attempts
- **Backoff**: Exponential backoff (1s, 2s, 4s)
- **Client Errors (4xx)**: Not retried (fix your endpoint)
- **Server Errors (5xx)**: Retried

### Delivery Status

You can monitor webhook delivery status in your dashboard:

- **Last Triggered**: Timestamp of last webhook delivery
- **Last Response Status**: HTTP status code from your endpoint
- **Failure Count**: Number of consecutive failures

<Warning>
  If a webhook fails repeatedly, consider checking your endpoint and fixing any
  issues. High failure counts may indicate problems with your webhook handler.
</Warning>

## Example: Complete Webhook Handler

Here's a complete example of a webhook handler with signature verification and async processing:

<CodeGroup>
```javascript Node.js
const express = require('express');
const crypto = require('crypto');
const { Queue } = require('bullmq');

const app = express();
app.use(express.json());

const webhookQueue = new Queue('webhooks', {
connection: { host: 'localhost', port: 6379 }
});

function verifyWebhookSignature(payload, signature, secret) {
const expectedSignature = crypto
.createHmac('sha256', secret)
.update(JSON.stringify(payload))
.digest('hex');

return crypto.timingSafeEqual(
Buffer.from(signature),
Buffer.from(expectedSignature)
);
}

app.post('/webhooks/dhmad', async (req, res) => {
const signature = req.headers['x-webhook-signature'];
const event = req.headers['x-webhook-event'];
const secret = process.env.DHMAD_WEBHOOK_SECRET;

// Verify signature
if (!verifyWebhookSignature(req.body, signature, secret)) {
return res.status(401).json({ error: 'Invalid signature' });
}

// Return 200 OK immediately
res.status(200).json({ received: true });

// Process webhook asynchronously
await webhookQueue.add('process-webhook', {
event,
payload: req.body,
receivedAt: new Date().toISOString()
});
});

// Worker to process webhooks
const worker = new Worker('webhooks', async (job) => {
const { event, payload } = job.data;

if (event === 'escrow.status.updated') {
const { escrow } = payload.data;
console.log(`Escrow ${escrow.id} status changed: ${escrow.oldStatus} → ${escrow.status}`);
// Update your database, send notifications, trigger other actions
} else if (event === 'contract.signed') {
const { contract, escrow } = payload.data;
console.log(`Contract ${contract.id} signed by ${contract.signedBy} for escrow ${escrow.id}`);
// Update your database, notify when both parties have signed (contract.isFullySigned)
}
});

app.listen(3000, () => {
console.log('Webhook server listening on port 3000');
});

````

```python Python
from flask import Flask, request, jsonify
import hmac
import hashlib
import json
import os
from celery import Celery

app = Flask(__name__)
celery = Celery('webhooks', broker='redis://localhost:6379/0')

def verify_webhook_signature(payload, signature, secret):
    expected_signature = hmac.new(
        secret.encode('utf-8'),
        json.dumps(payload, separators=(',', ':')).encode('utf-8'),
        hashlib.sha256
    ).hexdigest()

    return hmac.compare_digest(signature, expected_signature)

@app.route('/webhooks/dhmad', methods=['POST'])
def webhook():
    signature = request.headers.get('X-Webhook-Signature')
    event = request.headers.get('X-Webhook-Event')
    secret = os.getenv('DHMAD_WEBHOOK_SECRET')
    payload = request.get_json()

    # Verify signature
    if not verify_webhook_signature(payload, signature, secret):
        return jsonify({'error': 'Invalid signature'}), 401

    # Return 200 OK immediately
    response = jsonify({'received': True})

    # Process webhook asynchronously
    process_webhook.delay(event, payload)

    return response, 200

@celery.task
def process_webhook(event, payload):
    if event == 'escrow.status.updated':
        escrow = payload['data']['escrow']
        print(f"Escrow {escrow['id']} status changed: {escrow['oldStatus']} → {escrow['status']}")
        # Update your database, send notifications, trigger other actions
    elif event == 'contract.signed':
        contract = payload['data']['contract']
        escrow = payload['data']['escrow']
        print(f"Contract {contract['id']} signed by {contract['signedBy']} for escrow {escrow['id']}")
        # Update your database, notify when both parties have signed (contract['isFullySigned'])

if __name__ == '__main__':
    app.run(port=3000)
````

</CodeGroup>

## Testing Webhooks

### Using ngrok (Local Development)

To test webhooks locally, use ngrok to expose your local server:

```bash
# Install ngrok
npm install -g ngrok

# Start your webhook server
node server.js

# In another terminal, expose it
ngrok http 3000

# Use the ngrok URL in your webhook configuration
# Example: https://abc123.ngrok.io/webhooks/dhmad
```

### Testing Checklist

- [ ] Webhook endpoint returns 200 OK
- [ ] Signature verification works correctly
- [ ] Event processing handles all status transitions
- [ ] Duplicate events are handled idempotently
- [ ] Errors are logged but don't fail the response
- [ ] Webhook works in production (HTTPS)

## Troubleshooting

### Webhook Not Receiving Events

1. **Check Webhook Status**: Ensure the webhook is active in your dashboard
2. **Verify URL**: Make sure the URL is correct and accessible
3. **Check HTTPS**: In production, ensure your endpoint uses HTTPS
4. **Review Logs**: Check your server logs for incoming requests
5. **Test Endpoint**: Manually POST to your endpoint to verify it works

### Invalid Signature Errors

1. **Verify Secret**: Ensure you're using the correct webhook secret
2. **Check Payload Format**: Make sure you're stringifying the payload correctly
3. **Header Name**: Verify you're reading `X-Webhook-Signature` (case-sensitive)

### High Failure Count

1. **Response Time**: Ensure your endpoint responds within 10 seconds
2. **Status Code**: Return 200 OK for successful processing
3. **Error Handling**: Don't throw errors that cause 500 responses
4. **Network Issues**: Check for firewall or network problems

## Webhook Management

### Viewing Webhooks

In your dashboard, you can:

- View all your webhooks
- See delivery status and failure counts
- Check last triggered timestamp
- View last response status

### Updating Webhooks

You can update webhook URLs and toggle active/inactive status from the dashboard.

### Deleting Webhooks

Delete webhooks you no longer need. Remember, you can only have 2 webhooks maximum.

---

<Info>
  Webhooks are delivered for escrows where your associated user account is the
  seller or buyer, **or** for escrows created through your developer account via
  the API (tracked by `createdByDeveloper`). This means if you create escrows
  with a `sellerEmail`, you'll still receive webhook notifications for those
  escrows.
</Info>

<Warning>
  Never expose your webhook secret. Treat it like a password and store it
  securely using environment variables or secret management services.
</Warning>
